# 简单文法

​	初步实验

​	Pascal语法介绍：https://blog.csdn.net/bytxl/article/details/41010845

## 类型介绍

**类型      数值范围           占字节数       格式
**shortint   -128..128            1       带符号8位
inteter    -32768..32767          2       带符号16位

**类型       数值范围       占字节数      有效位数**
real      2.9e-39..1.7e38      6        11..12

**类型       数值范围       占字节数      有效位数**

char			0-127					1

**类型       数值范围       占字节数      有效位数**

bool									1

## 初步使用的保留字

### 关键字

| program |
| ------- |
| var     |
| integer |
| real    |
| char    |
| begin   |
| end     |

### 界符

| ,    |
| ---- |
| :    |
| ;    |
| :=   |
| *    |
| /    |
| +    |
| -    |
| .    |
| (    |
| )    |

## 文法介绍

### 符号介绍

~~后续需要扩展的内容~~ 

**关键字**

*<非终结符/界符>*

(a|b|c|d|e)：文法可选项

[可选项]

{重复可选项}

### 简单文法

*<程序>*		::=    **program** *<标识符>* **;**  *<分程序>* **.**     //注意 分号，句点

*<分程序>*	::=    [*<常量说明部分>*] [*<变量说明部分>*]  ~~{[*<过程说明部分>*]|[*<函数说明部分>*]}~~  *<复合语句>*

*<常量说明部分>*	::=    **const** *<常量定义>* {**,** *<常量定义>*};			//const 开头，';'结尾

<常量定义>	::=    <标识符>**＝**<常量>

​	<标识符>	::=    <字母>{<字母>|<数字>}  //标识符可以直接根据token判断，无需在语法分析里判断

​	<字母>		::=    a|b|c|d…x|y|z |A|B…|Z

​	<数字>		::=    0|1|2|3…8|9

​	<常量>		::=    [**+|-**] <无符号整数> | <字符>  

​	<无符号整数>	::=    <数字>{<数字>}//实际整数可以直接根据token来判断，无需在语法分析里判断

​	<字符>		::=    '<字母>'|'<数字>'//字符同样可以通过token来判断

<变量说明部分>	::=    **var** <变量说明> **;** {<变量说明>**;** }			//var 开头，';'结尾

​	<变量说明>	::=    <标识符>{**,**<标识符>} **:** <类型>

​	<类型>		::=    <基本类型>   ~~|array'['<无符号整数>']'of<基本类型>~~

​	<基本类型> ::=**integer**（2字节）|**char**（1字节）|**bool**(1字节)| ~~**real**(4字节)|~~

<复合语句>	::=    **begin**<语句>{**;**<语句>}**end** 	//以begin 开头，end结尾，最后一个语句不需要'**;**'结束，但因为存在空语句，从这种意义上来说也可以用 ；结尾

<*语句*>	::=    <赋值语句>|<空>~~|<返回值语句>|<条件语句>|<当循环语句>|<过程调用语句>|<复合语句>|<读语句>|<写语句>|<for循环语句>~~

<赋值语句>	::=    <标识符>**:=**<表达式>~~|<标识符>'['<表达式>']':=<表达式>~~

<表达式>	::=    **[+|-]** <项> {<加减法运算符><项>}

<项> ::= <因子> {<乘除法运算符> <因子>}

<因子> ::= <标识符>|<无符号整数>|'('<表达式>')'~~|<标识符>'['<表达式>']'~~~~|<函数调用语句>~~

<加法运算符>	::=    **+|-**
<乘法运算符>	::=    ***|/**

## 测试样例

样例

```pascal
program example;
	const c=3;
    var a,b:integer;
begin			//(beginProgram,example,_,_)
    a:=2+c; 	//(add,2,c,t1)	(assign,t1,_,a)
    b:=2*5+a	//(MUL,2,5,t2)	(add,t2,a,t3)	(assign,t3,_,b)
end.			//(endProgram,example,_,_)


//
program Hello;
	var ans:integer;
	function A(var x:integer):integer;
		var c,d:integer;
		begin
			x:=4;		//(assign,4,_,x)	
			c=x+3;		//(ADD,x,3,t)
			c:=3;
			d:=4;
			A:=c+d+x;
		end;
begin
	ans:=3;
	ans:=A(ans);
  	writeln ('Hello, world!')
end.

```

## 词法分析注意

词法分析部分将带符号数处理为 界符+无符号数，即数值常量只存在非负数

- 1.单行注释

  **{大括号里的内容都被注释掉}**

- 2.单行注释2

  ***//这种注释几乎是绝大部分语言中通用的了***

- 3.多行注释

  ***(\* pascal的多行注释有点奇怪，使用的是：括号+星号的方式 \*)***  

## 语法分析注意

​	需要对语法进行一定的变换

## 语义分析注意

​	

## 中间代码优化注意



## 目标代码优化注意





## 第二阶段

增加 if语句 while语句

## 第三阶段

怎加函数/过程定义调用，估计需要删除这一阶段







## 语法信息

### 关键字种类

| **关键字**     | **作用**                 | **关键字**    | **作用**          | **关键字**     | **作用**                 |
| -------------- | ------------------------ | ------------- | ----------------- | -------------- | ------------------------ |
| absolute       | 指令 (变量)              | abstract      | 指令 (方法)       | and            | 运算符 (布尔)            |
| array          | 类型                     | as            | 运算符 (RTTI)     | asm            | 语句                     |
| assembler      | 向后兼容 (汇编)          | at            | 语句 (异常处理)   | automated      | 访问类别符 (类)          |
| begin          | 块标记                   | case          | 语句              | cdecl          | 函数调用协定             |
| class          | 类型                     | const         | 声明或指令(参数)  | constructor    | 特殊方法                 |
| contains       | 运算符 (集合)            | default       | 指令 (属性)       | destructor     | 特殊方法                 |
| dispid         | dispinterface 界面类别符 | dispinterface | 类型              | div            | 运算符                   |
| do             | 语句                     | downto        | 语句 (for)        | dynamic        | 指令 (方法)              |
| else           | 语句 (if 或 case)        | end           | 块标记            | except         | 语句 (异常处理)          |
| export         | 向后兼容 (类)            | exports       | 声明              | external       | 指令 (函数)              |
| far            | 向后兼容 (类)            | file          | 类型              | finalization   | 单元结构                 |
| finally        | 语句 (异常处理)          | for           | 语句              | forward        | 函数指令                 |
| function       | 声明                     | goto          | 语句              | if             | 语句                     |
| implementation | 单元结构                 | implements    | 指令 (属性)       | in             | 运算符 (集合) - 工程结构 |
| index          | 指令(dipinterface界面)   | inherited     | 语句              | initialization | 单元结构                 |
| inline         | 向后兼容 (见 asm)        | interface     | 类型              | is             | 运算符 (RTTI)            |
| label          | 声明                     | library       | 程序结构          | message        | 指令 (方法)              |
| mod            | 运算符 (数学)            | name          | 指令 (函数)       | near           | 向后兼容 (类)            |
| nil            | 数值                     | nodefault     | 指令 (属性)       | not            | 运算符 (布尔)            |
| object         | 向后兼容 (类)            | of            | 语句 (case)       | on             | 语句 (异常处理)          |
| or             | 运算符 (布尔)            | out           | 指令 (参数)       | overload       | 函数指令                 |
| override       | 函数指令                 | package       | 程序结构 (控件包) | packed         | 指令 (记录)              |
| pascal         | 函数调用协定             | private       |                   |                |                          |

### 界符种类

- 运算符

| **运算符**     | **含义**     | **运算量类型** | **运算结果类型**       |                |
| -------------- | ------------ | -------------- | ---------------------- | -------------- |
| **:=**         | **赋值**     | **任何类型**   |                        |                |
| **算术运算符** | **+**        | **加**         | **整型或实型**         | **整型或实型** |
| **-**          | **减**       |                |                        |                |
| *****          | **乘**       |                |                        |                |
| **/**          | **实除**     | **实型**       |                        |                |
| **div**        | **整除**     | **整型**       | **整型**               |                |
| **mod**        | **求余**     |                |                        |                |
| **关系运算符** | **=**        | **相等**       | **基本类型****字符串** | **布尔型**     |
| **<>**         | **不等**     |                |                        |                |
| **<**          | **小于**     |                |                        |                |
| **>**          | **大于**     |                |                        |                |
| **<=**         | **小于等于** |                |                        |                |
| **>=**         | **大于等于** |                |                        |                |
| **逻辑运算符** | **not**      | **非**         | **布尔型**             | **布尔型**     |

- 分隔符

| ,    |      |
| ---- | ---- |
| .    |      |
| :    |      |
| ;    |      |
| (    |      |
| )    |      |
| {    |      |
| }    |      |

##

### 函数嵌套定义与调用

pascal函数只允许调用直属函数与同级在他之前被定义的函数。且自身所属函数的优先级高

如

```pascal
program Hello;

procedure A1();//             	(pro,A1,_,_)  A1:
	var a,b,c,d,e,f:inter;		(+);
								(write,)
                                ....
                                (endpro,a1,_,_)
	procedure B();
	begin
		c=a+3;
		writeln ('Hello, Max!')
		
	end;

begin
	writeln('Hello, Min!')
end;

function xxx():bool;
begin
	xxx=0;//(:=,0,_,xxx)
end

procedure A2();
begin
	A1();//正确
	B();//错误
	writeln('Hello, Other!');
end;

begin
	a  =   xxx();//(call,(xxx,_),_,_)
				//(:=,(hello,xxx_1),_,(hello,xxx_1))
									
				//(:=,t,_,x)
	A1();//正确			(call,a1_,_)->/*活动记录压栈的目标代码，调用函数的目标代码
	A2();//正确
	B();//错误
end.

```



