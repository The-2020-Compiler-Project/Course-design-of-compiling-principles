# 四元式生成格式

总体上和之前说过的一样，使用（op，A，B，DEST）

op为操作符，如（+，-，*，/，j< 等等）

A，B为操作数，如果是函数/过程则为（fname，empty）	//（函数/过程名，空）

​							如果是变量则为（fname，cname）			//（函数/过程名，变量名）

​							如果是常量则为（empty，cname）			//（空，常量名）

DEST为目标位置，和变量类似，为（fname，cname）			//（函数/过程名，变量名）

empty请用"_"表示，如果不方便的话可以修改＜（＾－＾）＞

如（op，（xxx，xxx），（xxx，xxx），（xxx，xxx））



下面的仅仅是格式，中间的东西（如a，b）可能是函数，变量什么的。

如果涉及函数/过程，就按照上面说的函数/过程的样子写

如果涉及变量，就按照变量的样子写

如果涉及常量，就按照常量的样子写

如：c=a+b如果为常量加常量赋给变量，则四元式应为(+,(\_,a),(\_,b),(c所在的函数名,c))



如果具体的生成有困难的话可以修改(。・∀・)ノ

有的和ppt上有点区别，不过区别不大，如果有困难的话也可以改~(￣▽￣)~*



## 具体格式

- +

  c:=a+b	->	(+,a,b,t1)

  ​					  (:=,t1,_,c)

  

- -

  c:=a-b	->	(-,a,b,t1)

  ​				     (:=,t1,_,c)

  

- *

  c:=a\*b	->	(*,a,b,t1)

  ​				      (:=,t1,_,c)

  

- /

  c:=a/b	->	(/,a,b,t1)

  ​				      (:=,t1,_,c)

  

- :=

  c:=a	->	   (:=,a,_,c)

  

- \>

  a>b	->		(>,a,b,t1)

  

- \>=

  a>=b  ->		(>=,a,b,t1)

  

- \<

  a<b	->		(<,a,b,t1)

  

- \<=

  a<=b  ->	    (<=,a,b,t1)

  

- =

  a=b	->		(=,a,b,t1)

  

- <>

  a<>b  ->		(<>,a,b,t1)

  

- if

  if xx then	->		(if,t1,_,a)	//t1为判断语句结果存放变量，如判断语句为a>b，则t1为a>b四元式中的t1

  ​										          //a为跳转目标四元式的编号

  ​										          //此处为假跳，如果判断语句为a>b，则a<=b时跳转

  

  else	->		（el,\_,\_,a)  //a为跳转目标四元式的编号

  ​									      	 //此处直接跳转到if结束的四元式

  

  if里的东西都写完了之后还有一个(ie,\_,\_,\_)，用于结束if

  

  例子：if a>b then

  ​				x:=(a+b)\**c;*

  ​			else 

  ​				x:=5-a\*b;

  四元式为：(>,a,b,t1)		//编号目前从0开始，如果生成四元式不方便的话可以改为从1开始

  ​					(if,t1,_,5)

  ​					(+,a,b,t2)

  ​					(*,t2,c,x)

  ​					(el,\_,\_,7)

  ​					(*,a,b,t3)

  ​					(-,5,t3,x)

  ​					(ie,\_,\_,\_)

  ​					xxx

  

- while

  while xx do	->		(wh,t1,_,a)	//t1为判断语句结果存放变量，如判断语句为a>b，则t1为a>b四元式中的t1

  ​														  //此处为假跳，如果不满足条件则直接跳转到结束while的四元式之后第一条四元式

  

  while里的东西都写完了之后还有一个(we,\_,\_,\_)，用于结束while

  

  例子：while a>b do

  ​				begin

  ​				x:=(a+b)\*c;

  ​				end;

  四元式为：(>,a,b,t1)		//编号目前从0开始，如果生成四元式不方便的话可以改为从1开始

  ​					(wh,t1,\_,5)

  ​					(+,a,b,t2)

  ​					(*,t2,c,x)

  ​					(we,\_,\_,\_)

  ​					xxx

  ​				

- procedure/fuction

  函数分为有返回值的和没有返回值的。有返回值的话就在函数中申请和函数同名的临时变量存储返回值。

  如fuction xxx的返回值就为xxx:=a，xxx为申请的临时变量，存在符号表中

  目前的想法是声明时正常声明，调用时四元式跳转到声明的四元式的位置

  这部分可以先不管

  

  定义过程：

  procedure a	->	(procedure,a,\_,\_)	//此时给他生成一个标号，用于后续调用时call

  end	->	(pe,\_,\_,\_)	   	//此时目标代码应该生成函数结束的语句

  

  调用过程：目前先考虑不含参数的

  a();	->	(callp,a,\_,\_)		//生成目标代码时去在已经存下来的函数标号中找对应的标号，之后直接call

  

  定义函数：

  function a()	->	(function,a,\_,\_)	//此时给他生成一个标号，用于后续调用时call

  ...(函数内容)

  a:=xxx	->	(:=,xxx,\_,a)		//把返回值赋给和函数同名的临时变量

  end	->	(fe,\_,\_,\_)	     	//此时目标代码应该生成函数结束的语句

  

  调用函数：目前先考虑不含参数的

  1. 无返回值：

     a();	->	（callf,a,\_,\_)		//生成目标代码时去在已经存下来的函数标号中找对应的标号，之后直接call

  2. 有返回值：

     b=a();	->	(:=,a,\_,b)	    //此处a为与函数同名的临时变量，别搞混了

     

  

- program

  program a	->	(program,a,\_,\_)
