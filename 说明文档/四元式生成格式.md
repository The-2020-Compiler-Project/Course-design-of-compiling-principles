# 四元式生成格式

总体上和之前说过的一样，使用（op，A，B，DEST）

op为操作符，如（+，-，*，/，j< 等等）

A，B为操作数，如果是函数/过程则为（fname，empty）	//（函数/过程名，空）

​							如果是变量则为（fname，cname）			//（函数/过程名，变量名）

​							如果是常量则为（empty，cname）			//（空，常量名）

DEST为目标位置，和变量类似，为（fname，cname）			//（函数/过程名，变量名）

如果为跳转指令，则把DEST的cname替换成目标四元式的编号，从0开始（有困难的话可以改）

empty请用"_"表示，如果不方便的话可以修改＜（＾－＾）＞

如（op，（xxx，xxx），（xxx，xxx），（xxx，xxx））






下面的仅仅是格式，中间的东西（如a，b）可能是函数，变量什么的。

如果涉及函数/过程，就按照上面说的函数/过程的样子写

如果涉及变量，就按照变量的样子写

如果涉及常量，就按照常量的样子写

如：c=a+b如果为常量加常量赋给变量，则四元式应为(+,(\_,a),(\_,b),(c所在的函数名,c))



如果具体的生成有困难的话可以修改(。・∀・)ノ

有的和ppt上有点区别，不过区别不大，如果有困难的话也可以改~(￣▽￣)~*



## 具体格式

- +

  c:=a+b	->	(+,a,b,t1)

  ​					  (:=,t1,_,c)

  

- -

  c:=a-b	->	(-,a,b,t1)

  ​				     (:=,t1,_,c)

  

- *

  c:=a\*b	->	(*,a,b,t1)

  ​				      (:=,t1,_,c)

  

- /

  c:=a/b	->	(/,a,b,t1)

  ​				      (:=,t1,_,c)

  

- :=

  c:=a	->	   (:=,a,_,c)

  

- \>

  a>b	->		(>,a,b,t1)

  

- \>=

  a>=b  ->		(>=,a,b,t1)

  

- \<

  a<b	->		(<,a,b,t1)

  

- \<=

  a<=b  ->	    (<=,a,b,t1)

  

- =

  a=b	->		(=,a,b,t1)

  

- <>

  a<>b  ->		(<>,a,b,t1)

  

- if

  //t1为判断语句结果存放变量，如判断语句为a>b，则t1为a>b四元式中的t1

  //a为跳转目标四元式的编号

  //此处为假跳，如果判断语句为a>b，则a<=b时跳转

  if xx then	->		(if,t1,_,a)	

  

  //a为跳转目标四元式的编号

  //此处直接跳转到if结束的四元式

  else	->		（el,\_,\_,a)  

  

  if里的东西都写完了之后还有一个(ie,\_,\_,\_)，用于结束if

  

  例子：if a>b then

  ​				x:=(a+b)\**c;*

  ​			else 

  ​				x:=5-a\*b;

  //编号目前从0开始，如果生成四元式不方便的话可以改为从1开始

  四元式为：(>,a,b,t1)		

  ​					(if,t1,_,5)

  ​					(+,a,b,t2)

  ​					(*,t2,c,x)

  ​					(el,\_,\_,7)

  ​					(*,a,b,t3)

  ​					(-,5,t3,x)

  ​					(ie,\_,\_,\_)

  ​					xxx

  

- while

  //t1为判断语句结果存放变量，如判断语句为a>b，则t1为a>b四元式中的t1

  //此处为假跳，如果不满足条件则直接跳转到结束while的四元式之后第一													      //条四元式

  while xx do	->		(wh,t1,_,a)	

  

  while里的东西都写完了之后还有一个(we,\_,\_,\_)，用于结束while

  

  例子：while a>b do

  ​				begin

  ​				x:=(a+b)\*c;

  ​				end;

  //编号目前从0开始，如果生成四元式不方便的话可以改为从1开始

  四元式为：(>,a,b,t1)		

  ​					(wh,t1,\_,5)

  ​					(+,a,b,t2)

  ​					(*,t2,c,x)

  ​					(we,\_,\_,\_)

  ​					xxx

  ​				

- procedure/fuction

  函数分为有返回值的和没有返回值的。有返回值的话就在函数中申请和函数同名的临时变量存储返回值。

  如fuction xxx的返回值就为xxx:=a，xxx为申请的临时变量，存在符号表中

  目前的想法是声明时正常声明，调用时四元式跳转到声明的四元式的位置

  这部分可以先不管

  

  定义过程：

  procedure a	->	(procedure,a,\_,\_)	//此时给他生成一个标号，用于后续调用时call

  end	->	(pe,\_,\_,\_)	   	//此时目标代码应该生成函数结束的语句

  

  调用过程：目前先考虑不含参数的

  a();	->	(callp,a,\_,\_)		//生成目标代码时去在已经存下来的函数标号中找对应的标号，之后直接call

  

  定义函数：

  function a()	->	(function,a,\_,\_)	//此时给他生成一个标号，用于后续调用时call

  ...(函数内容)

  a:=xxx	->	(:=,xxx,\_,a)		//把返回值赋给和函数同名的临时变量

  end	->	(fe,\_,\_,\_)	   	//此时目标代码应该生成函数结束的语句

  

  调用函数：目前先考虑不含参数的

  1. 无返回值：

     a();	->	（callf,a,\_,\_)		//生成目标代码时去在已经存下来的函数标号中找对应的标号，之后直接call

  2. 有返回值：

     b=a();	->	(:=,a,\_,b)	//此处a为与函数同名的临时变量，别搞混了

     

  

- program

  program a	->	(program,a,\_,\_)

#### by_YCJ

```
1、if的四元式。
	在if的跳转四元式中，不存在跳转到的标号，因为if的跳转总是和esle 或者 endif匹配。
	匹配的方法可以参考教学PPT中目标代码生成那一部分语义栈的使用，大体的思想就是遇到if四元式了，需要生成一条 JMP代码，但是跳转到哪条代码现在无法确定，所以这条JMP代码的位置压栈，等我遇到一条else/endif时，我再弹栈，这时我就能确定JMP的跳转位置了。
	大致的模板：
	(if,(fnaem,ename),_,_)
	xxxx
	(else,_,_,_)
	xxxx
	(endif,_,_,_)
	：
	(LD,ax,_,(fname,ename))
	(CMP,ax,0,ax)
	(JS,_,_,?)		压栈
	xxxx
	(JMP,_,_,?)		弹栈，将当前代码的下一个位置返填回去，然后将这条代码压栈
	XXXX
	遇到(endif,_,_,_)弹栈，将当前代码的下一个位置返填回去，这条四元式不翻译成对应的目标代码
	//只是大致的模板，具体怎么翻译，翻译成什么还有细节需要考虑
2、while的四元式。
	while的四元式有一个开头标志（wh,_,_,_）用于while的结尾反跳回来
	(wh,_,_,_)
	xxxx					//条件对应的四元式
	(do,(fname,ename),_,_)	//假跳四元式
	XXXX					//具体执行内容
	(we,_,_,_)				//无条件跳转
3、关于有返回值的函数四元式定义。
	在调用函数的活动记录中有一个临时变量。
	在被调函数中有一个对临时变量的赋值语句。
	即通过被调函数直接修改调用函数的活动记录来返回返回值，这样给返回值多次赋值。
	关于这个临时变量叫什么，目标代码生成阶段并不需要知到。
```

