

# 符号表

## 符号表1.0 已废弃

本套符号表废弃

~~全局符号表名：table~~

~~目前不支持函数/过程标识符，因为Pascal的嵌套函数定义太吃屎了~~

## ~~功能~~

- ~~插入：~~

  ```c++
  int table.insert[TokenName]（name）
  ```

  [ TokenName]:token类型名

  返回：插入的位置，若返回-1则说明已存在同名符号

  ```c++
  //标识符插入
  table.insertIt（string name）
  //字符常量插入
  table.insertCt(char name)
  //字符串常量的插入
  table.insertSt(string name)
  //整型常量的插入
  table.insertNt(int num)
  //浮点型常量的插入
  table.inserRt(double num)
  ```

- ~~查找：~~

  ~~按名字查找~~

  ```
  table.find[tokenName](name)
  ```

  ```c++
  //标识符查找
  auto ans = iterator findIt(string name);
  	iterator->name,iterator->index,iterator->offset,iterator->type,iterator->kind,(待添加)
  //非标识符查找
  int findKt(string name);
  int findPt(string name);
  int findCt(char c);
  int findSt(string s);
  int findNt(int num);
  int findRt(double num);
  //返回：>=0:位置；-1：未查询到
  ```

  ~~按tokenType与index查找~~

  

  

- ~~删除~~

  ~~仅供中间代码生成/优化阶段使用，其余阶段不支持，因删除会导致大部分的index值不可用~~

  ```
  bool delet(name);
  bool delet(type,index);
  ```

  ~~0:删除成功，1:删除失败~~

## 符号表2.0

设计理念：分为面向词法分析、语法分析的部分和面向语义分析、目标代码生成的部分，一依旧采取全局变量的形式

面向词法分析、语法分析的符号表：sTable，相对于符号表1.0做了简单调整，删除了部分接口

面向语义分析、目标代码生成的符号表：xTable，基于符号表1.0重新设计，减弱封装，面向底层

### sTable:

#### 接口：

- 1：添加
```c++
  int stable.insert[TokenName]（name）
```

[ TokenName]:token类型名

  返回：插入的位置，若返回-1则说明已存在同名符号

  ```c++
  //标识符插入
  stable.insertIt（string name）
  //字符常量插入
  stable.insertCt(string name)
  //字符串常量的插入
  stable.insertSt(string name)
  //整型常量的插入
  stable.insertNt(int num)
  //浮点型常量的插入
  stable.inserRt(double num)
  ```


- 2：按名字查询返回位置

   ```
   int stable.find[tokenName](name)
   ```

    ```c++
    int findIt(string name);
    int findKt(string name);
    int findPt(string name);
    int findCt(char c);
    int findSt(string s);
    int findNt(int num);
    int findRt(double num);
    //返回：>=0:位置；-1：未查询到
    ```

- 3：按位置查询返回名字

   考虑到词法分析和语法分析阶段不需要对知到常量的值，所以不支持常量的查询

 ```
    string stable.search[tokenName](int index)
 ```

```c++
string searchKt(int index);
string searchPt(int index);
string searchIt(int index);
string searchNt(int index);
return :空字符串：没有找到
```



关于四元式的一些设计：

```
(OP,A,B,DEST)

OP:string
A/B:函数标识符(fname,empty)		
A/B:变量标识符(fname,ename)
A/B:常量(empty,cname)
所以A/B:(string,string)的形式存储

DEST为运算结果存储位置，即DEST为变量
(fname,sname)
```

​	有关函数返回值的实现，约定调用函数生成一个同名的临时变量，被调函数给返回值赋值时，使用函数名作为变量名进行查找。问题来了：生成同名变量会导致什么问题？1：与已有变量冲突，这个问题不用担心，因为Pascal文法本身就不支持这种用法。

​	允许变量和函数同名，不过这样会屏蔽掉可以调用的同名函数。

### xTable	2.0:

结构：树形结构，每个结点具有双亲指针、孩子表；

​	树中的每个结点代表一个函数/过程，key为名字。允许同名的结点，但我采取了一种巧妙的方式来使得每个结点在使用时是唯一的。

​	树有一个指针：root指向当前活跃的函数。初始化时，root指向一个虚结点sRoot。

​	树的生成，动态改变root的位置进行树的生成。一开始遇到“program”关键字，root所指向的结点（sRoot）的当前函数表增加一项，然后root指向这个新增项。然后每当遇到一个过程或者函数定义关键字时，查找root当前所指向的函数表的子函数表，若没有重名的则新增加一项，否则函数重定义报错，然后root指向新增的结点。当遇到“end”的时候，root返回父节点。

​	参数、变量、常量、类型等函数成员信息的增加，首先查看当前节点的成员信息表是否存在同名，若存在报错，否则增加。这也就说明参数、变量、常量、类型等不可重名，而这也和Pascal语法规则一致，巧妙的设计。

​	参数、变量、常量、类型等函数成员信息的查询，按照名字查询成员信息表，与之前的一大不同在于，这次关于类型名字的查询不是直接在类型信息表中查询，而是在成员信息表中找到这个，然后再用指针找到类型信息表项。那基本类型怎么查找呢？基本类型不会被定义，也就不会被加入函数成员信息表。这种担心是多余的，基本类型是关键字，而且也没有用类型名进行查找的。

​	函数的查询，根据当前函数的 level 可以知到当前节点可以向上找几层，对于root的每个父节点froot，froot以及旗下的**一级子函数**都是root可以调用的。

​	函数调用的相关设计，根据Pascal同名变量屏蔽同名函数的设计，可以先查询是否存在同名的非临时变量，若存在不可调用，报错，否则查找临时变量区，不存在话加入并填写基本信息。

​	函数表：

| 函数表 |        |                |            |              |          |                                                              |                |                                  |                      |               |
| ------ | ------ | -------------- | ---------- | ------------ | -------- | ------------------------------------------------------------ | -------------- | -------------------------------- | -------------------- | ------------- |
| 名字   | 层次号 | 类型指针       | 数据区区距 | 活动记录总长 | 参数个数 | 成员信息表（成员信息表的前几项一定是参数，因为过程首部在开头） | 临时变量信息表 | 入口地址（目标代码翻译程序填写） | 子函数表!!!!!        | 双亲指针!!!!! |
| name   | level  | typePoint      | offset     | len          | fn       | elemSheet                                                    | tmpSheet       | addr                             | sFunTable            | pFunPoint     |
| string | int    | cosnt iterator | int        | int          | int      |                                                              |                | string                           | （string,*funSheet） | funTablePoint |

​	函数成员信息表：

​	字符串哈希，然后map对应链表项

​	存储参数、类型定义、常量、变量；

| 函数成员信息表 |              |                                                    |              |
| -------------- | ------------ | -------------------------------------------------- | ------------ |
| name(string)   | type(Tpoint) | cat(enum cat)                                      | addr（void） |
|                |              | 换名形参vn、赋值形参vf、类型t、域名d、常量c、变量v |              |
| 参数名         |              | 形参                                               | 偏移量表指针 |
| 类型名         |              | 类型                                               | NULL         |
| 常量名         | 类型指针     | 常量                                               | string指针   |
| 变量名         | 类型指针     | 变量                                               | 偏移量表指针 |

​	有关偏移量的设定，所有参数、变量的偏移量都是顺序无缝的，因此删除一个临时变量将会导致大部分变量的偏移量改变：解决方案，临时变量的插入是在中间代码生成阶段完成的，而优化则是在中间代码生成完成实现的，那么是否可以在中间代码优化完后再进行临时变量的插入呢？还是说，采取临时变量表的形式，建立一个临时变量表，在优化阶段进行删除，然后将临时变量表加入符号表。

​	临时变量只能为基本类型，但他的类型的确定需要根据有关的变量/常量来确定，因此在中间代码生成阶段将其加入临时变量表，然后在优化阶段进行删除，最后将临时变量表并入函数信息表。

​	所以偏移量的设定方案，函数信息表有一个偏移量，初始值为活动记录数据区的偏移量，然后加入一个量增加一个长度。

临时变量表

字符串哈希

| 临时变量表   |              |
| ------------ | ------------ |
| name(string) | type(Tpoint) |

类型信息表

| 类型表     |      |                      |
| ---------- | ---- | -------------------- |
| Tval(类码) | len  | Tpoint(具体信息指针) |
| 基本类型   | 长度 |                      |
| ...        |      |                      |
| 数组类型   |      |                      |
| 结构体类型 |      |                      |

| 结构表     |             |                      |                        |
| ---------- | ----------- | -------------------- | ---------------------- |
| ID（域名） | OFF（区距） | TP（域成分类型指针） | next(结构体表的下一项) |

| 数组表 |      |                         |                      |
| ------ | ---- | ----------------------- | -------------------- |
| low    | up   | sIterator(成分类型指针) | Clen（成分类型长度） |

​	关于类型信息的存储问题，类型定义的时候增加类型信息，对于结构体的定义，将域的信息统一存储在结构体信息表中，在函数成员信息表中不做存储。

​	用于定义的时候，用类型名在函数信息表中查找而不是在类型信息表中查找，然后将指针复制给变量的类型信息指针。这样判断两个类型是否匹配时，可以用指针是否相等来判断。关于类型提升的，基于基本类型，可以定义一套类型提升的规则。同时在类型表中提供长度，可以用于BYTE PTR,WORD PTR等

#### XTable有关类型的操作的设计之前的Pascal语法的规定

- Pascal中关于标识符的定义的规定。

  一个函数/过程下的**定义的**函数/常量/变量/参数标识符的名字不允许相同，且不允许和所属函数/过程同名

- 符号的查询的原则的规定。

  就近原则，先查询本函数的成员信息表、子函数信息表，然后再查找外层的成员信息表、子函数信息表。

- 函数返回值变量的存储。

  在所有变量之前加入一个名为result的变量。这样所有函数的返回值的偏移量都相同，都存储在活动记录数据取的开头，同时这种设计使得目标代码/中间代码容易生成。

- 在一个函数中只允许对自身的返回值赋值。为此需要判断一个函数符号是否为当前函数的名字，可以实现。

1、find查询操作，当前结点查找一个标识符的信息，用于标识符定义时的查找

​	返回，0未定义，1已经定义

