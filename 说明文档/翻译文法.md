### 标识符定义性文法

<程序>					::=    program <标识符>$\color{#0000FF}{【创建主函数】}$$\color{red}{【函数迭代器；压入函数栈】}$：<分程序>  .



<分程序>				::=    [<类型定义部分>] [<常量说明部分>] [<变量说明部分>] {[<过程说明部分>]|[<函数说明部分>]}$\color{red}{【函数定义四元式】}$<复合语句>



<类型定义部分>	::=	type <类型定义> ; { <类型定义> ; }



<类型定义>		    ::=	<标识符> $\color{#0000FF}{【标识符，压入类型定义标识符栈】}$= ( <数组类型定义> | <结构体类型定义> )



<数组类型定义>	::=	array  '['<无符号整数>']' $\color{#0000FF}{【记录常数值】}$of <标识符>$\color{#0000FF}{【增加数组类型定义，类型定义标识符栈弹栈】}$



<结构体类型定义>::=	record <域名定义>; { <域名定义>;} end$\color{#0000FF}{【增加结构体类型定义，域名向量、域名类型向量清空】}$



<域名定义>		    ::=	<标识符>$\color{#0000FF}{【域名标识加入，域名向量】}$ : <类型>$\color{#0000FF}{【类型标识加入，域名类型向量】}$ 



<常量说明部分>	::=    const <常量定义>{ ,<常量定义>} ;



<常量定义>			::=    <标识符>$\color{#0000FF}{【记录常量标识符】}$ ＝<常量>$\color{#0000FF}{【增加常量定义】}$



<变量说明部分>	::=    var <变量说明> ; {<变量说明> ; }	



<变量说明>			::=    <标识符>$\color{#0000FF}{【 记录 标识符】}$ { , <标识符>$\color{#0000FF}{【记录标识符 】}$} : <类型>$\color{#0000FF}{【增加变量定义】}$

```
type 
	<标识符>=record
　　 	<域名1>:<类型1>;
　　 	<域名2>:<类型2>;
　　　	: :
　　　	: :
     <域名n>:<类型n>;
　　end;
　　<标识符>=record
　　 	<域名1>:<类型1>;
　　 	<域名2>:<类型2>;
　　　	: :
　　　	: :
     <域名n>:<类型n>;
　　end;
   <标识符> = array [无符号常量] of <类型> ;
```

<过程说明部分>	::=    <过程首部><分程序>;



<过程首部>			::=    procedure<标识符>$\color{#0000FF}{【增加过程】}$$\color{red}{【函数迭代器；压入函数栈】}$[<形式参数表>]$\color{#0000FF}{【新过程增加参数】}$;



<函数说明部分>	::=    <函数首部><分程序>;



<函数首部>			::=    function<标识符>[<形式参数表>] : <基本类型>;$\color{#0000FF}{【增加函数】}$$\color{#0000FF}{【新函数增加参数】}$$\color{red}{【函数迭代器；压入函数栈】}$//注意是先增加函数然后再增加参数



<形式参数表>		::=    '( '<形式参数段> { ; <形式参数段>} ')'



<形式参数段>		::=    [ var ] <标识符> $\color{#0000FF}{【记录标识符】}$ { , <标识符>$\color{#0000FF}{【记录标识符】}$ } : <基本类型>$\color{#0000FF}{【增加参数】}$



### 标识符使用阶段，此阶段所有的标识符类型确定

<复合语句>			::=    begin<语句>{;<语句>}end



<语句>					::=    <赋值语句>|<返回值语句>|<条件语句>|<调用语句>|<while循环语句>|<复合语句>|<空>



<赋值语句>			::=    <变量> := <表达式> $\color{red}{【生成赋值四元式】}$

$\color{red}{【生成赋值四元式】}$：从运算对象栈中弹出两个元素a、b，生成b赋值给a的四元式

<变量>					::= 	<形参/变量 类码为基本类型 的标识符>$\color{red}{【标识符压入运算对象栈】}$ | <变量、类码为数组 的标识符> '['<表达式>']'$\color{red}{【生成数组取地址四元式，将结果压栈】}$ | <变量、类码为结构体 的标识符>.<属于前一个标识符的域名 标识符>	

$\color{red}{【生成数组取地址四元式，将结果压栈】}$：

<返回值语句>		::=    result := <表达式> 		**//result作为特殊标识**



<条件语句>			 ::=    if<条件>then<语句>[else<语句>]



<条件>					 ::=    <表达式><关系运算符><表达式>								



<while循环语句>    ::=    while <条件> do<语句>；



<调用语句>			 ::=	<函数调用语句>|<过程调用语句>



<函数调用语句>     ::=    <函数 标识符>[<实在参数表>]



<过程调用语句>     ::=    <过程 标识符>[<实在参数表>]



<实在参数表>		 ::=    '(' <实在参数> { ,<实在参数>} ')'



<实在参数>			 ::=    <表达式> 







<表达式>				::=    [-]<项> {<加法运算符><项>}

<项>						::=    <因子> {<乘法运算符><因子>}

<因子>					::=   <变量>|<类码为整型 常量标识符>|<无符号整数>|'('<表达式>')'|<函数调用语句>



<类型>					::=    <基本类型> |<类型 标识符>

<基本类型>			::=    integer|char|bool

<布尔值>				::=    true|false





//可以通过token直接区分出来的单词

<加法运算符>		::=    +|-

<乘法运算符>		::=    \*|/

<关系运算符>		::=    <|<=|>|>=|=|<>

<字母>					::=    a|b|c|d…x|y|z |A|B…|Z

<数字>					::=    0|1|2|3…8|9

<常量>					::=    [+|-] <无符号整数>|<字符>

<字符>					::=    '<字母>'|'<数字>'

<字符串>				::=    "{十进制编码为32,33,35-126的ASCII字符}"

<无符号整数>		::=    <数字>{<数字>}

<标识符>				::=    <字母>{<字母>|<数字>}



## 翻译文法部分的设计

翻译文法的接口以类的形式实现、依赖于文法分析的结果，在文法分析的语义动作后执行

完成的工作有：四元式生成、语义分析

重复定义的检查在文法分析阶段可以完成大部分



关键字增加 result,true,false,call



```
program ex;
　　var
　　　　x:real;
　　　　y:integer;
　　begin
　　　　if x>0　then y:=1｛x>0时，y的值为1｝
　　　　　else ｛x≤0时｝
　　　　　　if x=0　then y:=0
　　　　　　else y:=-1;
　　　　writeln('x=',x:6:2,'y=',y);
	end.
	
	
program ex;
　　var
　　　　x:real;
　　　　y:integer;
　　begin
　　　　if x>0　then y:=1｛x>0时，y的值为1｝
　　　　　else ｛x≤0时｝
　　　　　　if x=0　then y:=0
　　　　　　else y:=-1;
　　　　writeln('x=',x:6:2,'y=',y);
	end.
```

