### 标识符定义性文法

<程序>					::=    program <标识符>$\color{#0000FF}{【创建主函数】}$$\color{red}{【函数迭代器；压入函数栈】}$$\color{red}{【生成函数定义开始四元式】}$：<分程序>  .

$\color{red}{【生成函数定义开始四元式】}$：读取函数栈栈顶，生成一条标识函数定义开始的四元式，用于目标代码获取函数迭代器。



<分程序>				::=    [<类型定义部分>] [<常量说明部分>] [<变量说明部分>] {[<过程说明部分>]|[<函数说明部分>]}$\color{red}{【函数代码段开始四元式】}$<复合语句>$\color{red}{【函数定义结束四元式】}$

$\color{red}{【函数代码 段开始四元式】}$：生成函数代码段开始四元式。

$\color{red}{【函数定义结束四元式】}$：弹函数栈，生成函数定义结束四元式。



<类型定义部分>	::=	type <类型定义> ; { <类型定义> ; }



<类型定义>		    ::=	<标识符> $\color{#0000FF}{【标识符，压入类型定义标识符栈】}$= ( <数组类型定义> | <结构体类型定义> )



<数组类型定义>	::=	array  '['<无符号整数>']' $\color{#0000FF}{【记录常数值】}$of <标识符>$\color{#0000FF}{【增加数组类型定义，类型定义标识符栈弹栈】}$

$\color{blue}{【记录】}$：指的是记录下的string在本语句中被使用

$\color{blue}{【压入某某栈】}$：标识一个标识符用于其他语句



<结构体类型定义>::=	record <域名定义>; { <域名定义>;} end$\color{#0000FF}{【增加结构体类型定义，域名向量、域名类型向量清空】}$



<域名定义>		    ::=	<标识符>$\color{#0000FF}{【域名标识加入，域名向量】}$ : <类型>$\color{#0000FF}{【类型标识加入，域名类型向量】}$ 



<常量说明部分>	::=    const <常量定义>{ ,<常量定义>} ;



<常量定义>			::=    <标识符>$\color{#0000FF}{【记录常量标识符】}$ ＝<常量>$\color{#0000FF}{【增加常量定义】}$



<变量说明部分>	::=    var <变量说明> ; {<变量说明> ; }	



<变量说明>			::=    <标识符>$\color{#0000FF}{【 记录 标识符】}$ { , <标识符>$\color{#0000FF}{【记录标识符 】}$} : <类型>$\color{#0000FF}{【增加变量定义】}$



```
type 
	<标识符>=record
　　 	<域名1>:<类型1>;
　　 	<域名2>:<类型2>;
　　　	: :
　　　	: :
     <域名n>:<类型n>;
　　end;
　　<标识符>=record
　　 	<域名1>:<类型1>;
　　 	<域名2>:<类型2>;
　　　	: :
　　　	: :
     <域名n>:<类型n>;
　　end;
   <标识符> = array [无符号常量] of <类型> ;
```

<过程说明部分>	::=    <过程首部><分程序>;



<过程首部>			::=    procedure<标识符>$\color{#0000FF}{【增加过程】}$$\color{red}{【函数迭代器；压入函数栈】}$$\color{red}{【生成函数定义开始四元式】}$[<形式参数表>]$\color{#0000FF}{【新过程增加参数】}$;



<函数说明部分>	::=    <函数首部><分程序>;



<函数首部>			::=    function<标识符>[<形式参数表>] : <基本类型>;$\color{#0000FF}{【增加函数】}$$\color{#0000FF}{【新函数增加参数】}$//$\color{red}{【函数迭代器；压入函数栈】}$$\color{red}{【生成函数定定义开始四元式】}$



<形式参数表>		::=    '( '<形式参数段> { ; <形式参数段>} ')'



<形式参数段>		::=    [ var ] <标识符> $\color{#0000FF}{【记录标识符，注意类型的不同】}$ { , <标识符>$\color{#0000FF}{【记录标识符】}$ } : <基本类型>$\color{#0000FF}{【增加参数】}$



### 标识符使用阶段，此阶段所有的标识符类型确定

<复合语句>			::=    begin<语句>{;<语句>}end



<语句>					::=    <赋值语句>|<返回值语句>|<条件语句>|<调用语句>|<while循环语句>|<复合语句>|<空>



<赋值语句>			::=    <变量> := <表达式> $\color{red}{【生成赋值四元式】}$

$\color{red}{【生成赋值四元式】}$：从运算对象栈中弹出两个元素a、b，生成b赋值给a的四元式



<变量>					::= 	<形参/变量 类码为基本类型 的标识符>$\color{red}{【标识符压入运算对象栈】}$ | <变量、类码为数组 的标识符>$\color{red}{【标识符压入运算对象栈】}$ '['<表达式>']'$\color{red}{【生成数组取地址四元式，将结果压栈】}$ | <变量、类码为结构体 的标识符> $\color{red}{【标识符压入运算对象栈】}$  .    <属于前一个标识符的域名 标识符>$\color{red}{【标识符压入运算对象栈】}$$\color{red}{【生成结构体域名地址获取四元式，将结果压入运算对象栈】}$

//变量的结果是运算对象栈+1，且一定只+1

$\color{red}{【生成数组取地址四元式，将结果压入运算对象栈】}$：新增point型类型时变量，从栈顶弹出元素a、b，生成数组取地址四元式。

$\color{red}{【生成结构体域名地址获取四元式，将结果压入运算对象栈】}$：新增point型，从栈顶取弹出元素a、b，生成结构体取地址四元式



<返回值语句>		::=    result := <表达式> $\color{red}{【生成返回值赋值语句】}$**//result作为特殊标识**

$\color{red}{【生成返回值赋值语句】}$：运算对象弹栈，生成返回值赋值



<条件语句>			 ::=    if<条件>then$\color{red}{【生成beginIF四元式】}$<语句>[else$\color{red}{【生成else四元式语句】}$<语句>]

$\color{red}{【生成endIf语句】}$



$\color{red}{【生成beginIf语句】}$:运算对象弹栈，生成if语句

$\color{red}{【生成else语句】}$:生成四元式

$\color{red}{【生成endIf语句】}$：生成四元式



<条件>					 ::=    <表达式><关系运算符>$\color{red}{【运算符压栈】}$<表达式>$\color{red}{【生成关系四元式】}$

$\color{red}{【生成关系四元式】}$：新增临时变量，运算对象弹出a、b，生成关系四元式b**a的四元式，运算结果压栈，用于if\while等语句的跳转判断



<while循环语句>    ::=    while$\color{red}{【生成beginWhile语句】}$ <条件> do$\color{red}{【生成do语句】}$<语句>；$\color{red}{【生成endWhile语句】}$

$\color{red}{【生成beginWhile语句】}$:生成四元式

$\color{red}{【生成do语句】}$：运算弹栈，生成四元式

$\color{red}{【生成endWhile语句】}$:生成四元式



<调用语句>			 ::=	<函数调用语句>$\color{red}{【运算对象弹栈】}$|<过程调用语句>

$\color{red}{【运算对象弹栈】}$：单纯的调用语句的返回值没用



<函数调用语句>     ::=    <函数 标识符>$\color{red}{【函数标识符压入函数调用栈】}$[<实在参数表>]$\color{red}{【生成参数传递四元式】}$$\color{red}{【生成函数调用四元式】}$$\color{red}{【生成获取函数返回值四元式】}$$\color{red}{【函数标识符弹栈】}$

$\color{red}{【生成参数传递四元式】}$：读取函数调用标识符栈的栈顶，判断参数的个数，然后弹运算对象栈，调整顺序，生成相对应的参数传递四元式，传值、传偏移量。

$\color{red}{【生成函数调用语句】}$：读取函数调用栈栈顶，生成函数调用语句

$\color{red}{【生成获取函数返回值四元式】}$：用函数调用栈的栈顶获取函数信息，生成对应类型的临时变量，然后生成获取返回值的四元式，临时变量符号压入操作对象栈

$\color{red}{【函数标识符弹栈操作】}$：函数标识符没用了，弹栈



<过程调用语句>     ::=    <过程 标识符>$\color{red}{【函数标识符压入函数调用栈】}$[<实在参数表>]$\color{red}{【生成参数传递四元式】}$$\color{red}{【生成函数调用四元式】}$$\color{red}{【函数标识符弹栈】}$



<实在参数表>		 ::=    '(' <实在参数> { ,<实在参数>} ')'



<实在参数>			 ::=    <表达式> 		$\color{red}{//表达式部分已经压栈}$







<表达式>				::=    [-]<项> {<加法运算符>$\color{red}{【运算符压入算符栈】}$<项>$\color{red}{【生成算数运算四元式】}$ }

$\color{red}{【生成算数运算四元式】}$：弹栈顶运算符、弹栈顶两个操作数，生成一个中间变量压栈，生成四元式



<项>						::=    <因子> {<乘法运算符>$\color{red}{【运算符压入算符栈】}$<因子>$\color{red}{【生成算数运算四元式】}$}



<因子>					::=   <变量>|<类码为整型 常量标识符>$\color{red}{【标识符取值压栈】}$|<无符号整数>$\color{red}{【常数压栈】}$|'('<表达式>')'|<函数调用语句>

$\color{red}{【标识符取值压栈】}$：将标识符的常量值压入运算对象栈，这样运算对象中存在变量标识符/常量值，无需做区分

$\color{red}{【常数】}$：常数string压栈



<类型>					::=    <基本类型> |<类型 标识符>

<基本类型>			::=    integer|char|bool

<布尔值>				::=    true|false





//可以通过token直接区分出来的单词

<加法运算符>		::=    +|-

<乘法运算符>		::=    \*|/

<关系运算符>		::=    <|<=|>|>=|=|<>

<字母>					::=    a|b|c|d…x|y|z |A|B…|Z

<数字>					::=    0|1|2|3…8|9

<常量>					::=    [-] <无符号整数>|<字符>

<字符>					::=    '<字母>'|'<数字>'

<字符串>				::=    "{十进制编码为32,33,35-126的ASCII字符}"

<无符号整数>		::=    <数字>{<数字>}

<标识符>				::=    <字母>{<字母>|<数字>}



## 规律

四元式生成的语义动作好像只需要加载标识符后边以及广义的算符后面



## 翻译文法部分的设计

翻译文法的接口以类的形式实现、依赖于文法分析的结果，在文法分析的语义动作后执行

完成的工作有：四元式生成、语义分析

重复定义的检查在文法分析阶段可以完成大部分



关键字增加 result,true,false,call



```
program ex;
　　var
　　　　x:real;
　　　　y:integer;
　　　　funciont  x( a,b,c,d,e):bool;
　　　　result:=123;
　　　　begin
　　　　end;
　　　　function t(a,b,c,d):bool;
　　　　begin
　　　　end;
　　begin
　　
　　	
	end.
	
	
program ex;
　　var
　　　　x:real;
　　　　y:integer;
　　begin
　　　　if x>0　then y:=1｛x>0时，y的值为1｝
　　　　　else ｛x≤0时｝
　　　　　　if x=0　then y:=0
　　　　　　else y:=-1;
　　　　writeln('x=',x:6:2,'y=',y);
	end.
```

